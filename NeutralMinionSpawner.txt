local NeutralMinionSpawner = {}

-- Servicios
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ğŸ”§ MÃ³dulos
local MinionAI = require(ReplicatedStorage:WaitForChild("MinionAI"))
local EquipoManager = require(ReplicatedStorage:WaitForChild("EquipoManager"))

-- ğŸ—ºï¸ ConfiguraciÃ³n de spawn points neutrales
local SPAWN_POINTS = {
	{
		name = "Jungla_Zona1_CampamentoPequeÃ±o",
		position = Vector3.new(-35.629, 10.698, 372.11),
		minionType = "JungleCreep1",
		respawnTime = 30,
		level = 1,
		minionCount = 3,  -- 3 MINIONS POR SPAWN
		spawnRadius = 8   -- RADIO DE DISPERSIÃ“N
	}
}

-- ğŸ“¦ Modelos de minions neutrales
local NEUTRAL_MINIONS = {
	JungleCreep1 = ServerStorage:WaitForChild("NeutralMinion1"),
}

local activeNeutralMinions = {}
local initialized = false

-- ğŸ†• FUNCIÃ“N PARA GENERAR POSICIONES DISTRIBUIDAS (CORREGIDA)
local function generarPosicionesDistribuidas(posicionCentral, cantidad, radio)
	local posiciones = {}

	for i = 1, cantidad do
		-- ğŸ†• CORRECCIÃ“N: Usar Ã¡ngulos equidistantes
		local angulo = (2 * math.pi / cantidad) * (i - 1)
		local offsetX = math.cos(angulo) * radio
		local offsetZ = math.sin(angulo) * radio

		local posicion = Vector3.new(
			posicionCentral.X + offsetX,
			posicionCentral.Y,
			posicionCentral.Z + offsetZ
		)
		table.insert(posiciones, posicion)
	end

	return posiciones
end

-- ğŸŒ± FunciÃ³n para spawnear un minion neutral en posiciÃ³n especÃ­fica
function NeutralMinionSpawner.SpawnNeutralMinion(spawnConfig, posicionEspecifica, minionIndex)
	if not spawnConfig then 
		warn("âŒ [NeutralMinionSpawner] spawnConfig es nil")
		return 
	end

	local nombreUnico = spawnConfig.minionType .. "_" .. minionIndex
	print("ğŸ”§ [NeutralMinionSpawner] Intentando spawnear minion: " .. nombreUnico .. " en " .. spawnConfig.name)

	if not NEUTRAL_MINIONS[spawnConfig.minionType] then
		warn("âŒ [NeutralMinionSpawner] Modelo no encontrado: " .. spawnConfig.minionType)
		return nil
	end

	local minionModel = NEUTRAL_MINIONS[spawnConfig.minionType]:Clone()
	minionModel.Name = nombreUnico
	print("âœ… [NeutralMinionSpawner] Modelo clonado: " .. minionModel.Name)

	-- ğŸ†• VERIFICAR Y CONFIGURAR PRIMARYPART
	if not minionModel.PrimaryPart then
		local humanoidRootPart = minionModel:FindFirstChild("HumanoidRootPart")
		if humanoidRootPart then
			minionModel.PrimaryPart = humanoidRootPart
		else
			-- Buscar cualquier BasePart
			local anyPart = minionModel:FindFirstChildWhichIsA("BasePart")
			if anyPart then
				minionModel.PrimaryPart = anyPart
			else
				warn("âŒ [NeutralMinionSpawner] No se pudo encontrar PrimaryPart para: " .. minionModel.Name)
				minionModel:Destroy()
				return nil
			end
		end
	end

	-- Configurar posiciÃ³n
	local posicionFinal = posicionEspecifica or spawnConfig.position
	minionModel:SetPrimaryPartCFrame(CFrame.new(posicionFinal))
	minionModel.Parent = workspace

	-- ğŸ·ï¸ Configurar como equipo neutral
	minionModel:SetAttribute("Equipo", "Neutral")
	minionModel:SetAttribute("EsMinion", true)
	minionModel:SetAttribute("EsNeutral", true)
	minionModel:SetAttribute("SpawnIndex", minionIndex)

	-- ğŸ’° Configurar recompensas
	local xpReward = Instance.new("IntValue")
	xpReward.Name = "XPReward"
	xpReward.Value = 50 * spawnConfig.level
	xpReward.Parent = minionModel

	local goldReward = Instance.new("NumberValue")
	goldReward.Name = "GoldReward" 
	goldReward.Value = 25 * spawnConfig.level
	goldReward.Parent = minionModel

	-- âš”ï¸ Configurar salud
	local humanoid = minionModel:FindFirstChildOfClass("Humanoid")
	if humanoid then
		local variacionSalud = math.random(-20, 20)
		humanoid.MaxHealth = (150 * spawnConfig.level) + variacionSalud
		humanoid.Health = humanoid.MaxHealth
		print("â¤ï¸ [NeutralMinionSpawner] Salud configurada: " .. humanoid.MaxHealth .. " HP para " .. minionModel.Name)
	else
		warn("âŒ [NeutralMinionSpawner] No se encontrÃ³ Humanoid en " .. minionModel.Name)
		minionModel:Destroy()
		return nil
	end

	-- ğŸ§  Iniciar IA
	local spawnPosicion = posicionEspecifica or spawnConfig.position
	local success, err = pcall(function()
		MinionAI.Start(minionModel, function(waypointIndex, waypointName)
			if waypointName == "FINISHED" then
				minionModel:SetPrimaryPartCFrame(CFrame.new(spawnPosicion))
			end
		end)
	end)

	if not success then
		warn("âŒ [NeutralMinionSpawner] Error al iniciar IA para " .. minionModel.Name .. ": " .. tostring(err))
		minionModel:Destroy()
		return nil
	end

	-- ğŸ’€ Configurar respawn al morir
	humanoid.Died:Connect(function()
		print("ğŸª¦ [NeutralMinionSpawner] Minion neutral muerto: " .. minionModel.Name)
		task.wait(spawnConfig.respawnTime)

		if minionModel and minionModel.Parent then
			minionModel:Destroy()
		end

		-- Respawnear en la misma posiciÃ³n especÃ­fica
		task.spawn(function()
			NeutralMinionSpawner.SpawnNeutralMinion(spawnConfig, spawnPosicion, minionIndex)
		end)
	end)

	activeNeutralMinions[minionModel] = true
	print("ğŸŒ¿ [NeutralMinionSpawner] MINION SPAWNEADO EXITOSAMENTE: " .. minionModel.Name)
	return minionModel
end

-- ğŸ¯ Inicializar todos los spawn points (CORREGIDO)
function NeutralMinionSpawner.Initialize()
	if initialized then
		print("âš ï¸ [NeutralMinionSpawner] Sistema YA inicializado, omitiendo...")
		return
	end

	print("ğŸš€ [NeutralMinionSpawner] INICIANDO SISTEMA...")
	print("ğŸ“Š [NeutralMinionSpawner] Total spawn points: " .. #SPAWN_POINTS)

	for i, spawnConfig in ipairs(SPAWN_POINTS) do
		print("ğŸ¯ [NeutralMinionSpawner] Procesando spawn point " .. i .. ": " .. spawnConfig.name)

		-- ğŸ†• CORRECCIÃ“N: Generar mÃºltiples minions
		local cantidadMinions = spawnConfig.minionCount or 1
		local radioDispersion = spawnConfig.spawnRadius or 5

		print("ğŸ‘¥ [NeutralMinionSpawner] Generando " .. cantidadMinions .. " minions con radio: " .. radioDispersion)

		if cantidadMinions > 1 then
			-- ğŸ†• CORRECCIÃ“N: Generar posiciones y spawnear TODOS los minions
			local posiciones = generarPosicionesDistribuidas(spawnConfig.position, cantidadMinions, radioDispersion)

			print("ğŸ“ [NeutralMinionSpawner] Total de posiciones generadas: " .. #posiciones)

			for j, posicion in ipairs(posiciones) do
				print("ğŸ“ [NeutralMinionSpawner] PosiciÃ³n minion " .. j .. ": " .. tostring(posicion))

				-- ğŸ†• CORRECCIÃ“N: Usar task.spawn para evitar bloqueos
				task.spawn(function()
					local success, err = pcall(function()
						NeutralMinionSpawner.SpawnNeutralMinion(spawnConfig, posicion, j)
					end)

					if not success then
						warn("âŒ [NeutralMinionSpawner] Error al spawnean minion " .. j .. ": " .. tostring(err))
					end
				end)

				-- PequeÃ±o delay entre spawns
				task.wait(0.2)
			end
		else
			-- Comportamiento normal para 1 minion
			NeutralMinionSpawner.SpawnNeutralMinion(spawnConfig, nil, 1)
		end
	end

	initialized = true
	print("âœ… [NeutralMinionSpawner] SISTEMA INICIALIZADO - " .. #SPAWN_POINTS .. " campamentos")
end

print("ğŸ“ [NeutralMinionSpawner] Script cargado - Esperando inicializaciÃ³n")

return NeutralMinionSpawner
--serverscriptservice
local BasicAttacks = {}

-- Cargar mÃ³dulos
local Players = game:GetService("Players")
local CombatManager = require(game.ServerScriptService:WaitForChild("CombatManager"))
local BasicAttackCooldown = require(game.ServerScriptService:WaitForChild("BasicAttackCooldown"))
local EstadoManager = require(game.ServerScriptService:WaitForChild("EstadoManager"))

-- ğŸš« FUNCIÃ“N: Verificar si el personaje puede atacar
local function personajePuedeAtacar(character)
	if not character then return false end

	-- ğŸŒ€ Verificar si estÃ¡ aturdido
	if EstadoManager.TieneEstado(character, "Aturdido") then
		print("ğŸŒ€ " .. character.Name .. " estÃ¡ aturdido, no puede atacar")
		return false
	end

	-- ğŸ›¡ï¸ Verificar si estÃ¡ bloqueado de ataque
	if EstadoManager.TieneEstado(character, "BloqueadoAtaque") then
		print("ğŸ›¡ï¸ " .. character.Name .. " estÃ¡ bloqueado, no puede atacar")
		return false
	end

	return true
end

-- Helper: Calculate level-based damage multiplier
local function getLevelMultiplier(character)
	local nivel = character:GetAttribute("Nivel") or 1
	local scalingFactor = 0.05 -- 5% extra damage per level above 1
	return 1 + ((nivel - 1) * scalingFactor)
end

-- âš¡ FUNCIÃ“N UNIFICADA PARA VERIFICAR ATAQUES
local function puedeAtacarObjetivo(atacante, objetivo)
	-- ğŸ” Resolver modelo del objetivo
	local targetModel = objetivo
	if objetivo:IsA("BasePart") or objetivo:IsA("MeshPart") then
		targetModel = objetivo:FindFirstChildOfClass("Model") or objetivo.Parent
	elseif objetivo:IsA("Humanoid") then
		targetModel = objetivo.Parent
	end

	if not targetModel then return false end

	-- âœ… USAR EQUIPOMANGER PARA VERIFICACIÃ“N CORRECTA
	return EquipoManager.PuedeAtacar(atacante, targetModel)
end

-- ğŸ”¥ FUNCIÃ“N DE ATAQUE BÃSICO QUE USA TU SISTEMA DE DAÃ‘O POR FUERZA
local function ejecutarAtaqueBasico(character, aplicarStun, multiplicadorFuerza)
	-- Verificar cooldown antes de atacar
	if not BasicAttackCooldown.canAttack(character) then
		return
	end

	-- ğŸš« VERIFICAR SI EL PERSONAJE PUEDE ATACAR
	if not personajePuedeAtacar(character) then
		return
	end

	local player = game.Players:GetPlayerFromCharacter(character)
	if not player then return end

	-- ğŸ¯ CALCULAR DAÃ‘O BASADO EN FUERZA (tu sistema)
	local fuerza = character:GetAttribute("Fuerza") or 0
	local nivelMultiplier = getLevelMultiplier(character)
	local multiplicador = multiplicadorFuerza or 1.0
	local danioBase = math.floor(fuerza * multiplicador * nivelMultiplier)

	print("âš”ï¸ [BasicAttack] Ataque bÃ¡sico de " .. character.Name .. " - DaÃ±o: " .. danioBase)

	-- ğŸ”¥ EJECUTAR HITBOX RÃPIDO - CombatManager se encargarÃ¡ del daÃ±o usando tu sistema
	CombatManager.HitboxRapido(player, danioBase, aplicarStun)
end

-- ğŸ¯ ATAQUES BÃSICOS POR PERSONAJE (RESPETANDO TU SISTEMA DE DAÃ‘O POR FUERZA)

-- âš”ï¸ Spartan - golpe fuerte con stun
BasicAttacks["Spartan"] = function(character, target)
	-- Verificar cooldown antes de atacar
	if not BasicAttackCooldown.canAttack(character) then
		return
	end

	-- ğŸš« VERIFICAR SI EL PERSONAJE PUEDE ATACAR
	if not personajePuedeAtacar(character) then
		return
	end

	print("âš”ï¸ Spartan basic attack fue llamado.")

	local player = Players:GetPlayerFromCharacter(character)
	if not player or not target then
		print("âŒ No hay player o target para Spartan.")
		return
	end

	-- ğŸš« VERIFICACIÃ“N CON EQUIPOMANGER
	if not puedeAtacarObjetivo(character, target) then
		print("âŒ Spartan no puede atacar a este objetivo (aliado o invÃ¡lido)")
		return
	end

	-- ğŸ” Resolver modelo del target
	local targetModel = target
	if target:IsA("BasePart") or target:IsA("MeshPart") then
		targetModel = target:FindFirstChildOfClass("Model") or target.Parent
	elseif target:IsA("Humanoid") then
		targetModel = target.Parent
	end

	if not targetModel then
		print("âŒ No se pudo encontrar el modelo del objetivo")
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	local targetHRP = targetModel and (targetModel:FindFirstChild("HumanoidRootPart") or targetModel.PrimaryPart)
	if not hrp or not targetHRP then
		print("âŒ No se encontrÃ³ HumanoidRootPart en alguno.")
		return
	end

	local distance = (hrp.Position - targetHRP.Position).Magnitude
	if distance > 6 then
		print("ğŸ“ Objetivo fuera de alcance.")
		return
	end

	-- ğŸ§  Calcular daÃ±o segÃºn Fuerza y Nivel
	local fuerza = character:GetAttribute("Fuerza") or 0
	local nivelMultiplier = getLevelMultiplier(character)
	local danioBase = math.floor(fuerza * 1.2 * nivelMultiplier)

	-- Usar el sistema de hitbox rÃ¡pido en lugar de daÃ±o directo
	CombatManager.HitboxRapido(player, danioBase, true) -- Stun aplicado
	print("ğŸ’¥ Spartan HitboxRapido activado - DaÃ±o: " .. danioBase)

	-- ğŸ”¥ Verificar si estÃ¡ activo el buff antes de aplicar daÃ±o en Ã¡rea
	local status = character:FindFirstChild("LlamasDelOlimpoActivas")
	if status then
		local radius = 6
		print("ğŸ”¥ DaÃ±o en Ã¡rea por Llamas del Olimpo...")

		for _, otherCharacter in pairs(workspace:GetChildren()) do
			if otherCharacter:IsA("Model") and otherCharacter ~= character then
				local otherHRP = otherCharacter:FindFirstChild("HumanoidRootPart") or otherCharacter.PrimaryPart
				if otherHRP then
					local dist = (targetHRP.Position - otherHRP.Position).Magnitude
					if dist <= radius then
						-- âœ… USAR EQUIPOMANGER PARA DAÃ‘O EN ÃREA
						if EquipoManager.PuedeAtacar(character, otherCharacter) then
							local areaDanio = math.floor(fuerza * 0.5 * nivelMultiplier)
							-- Usar daÃ±o directo para Ã¡rea (o podrÃ­as crear otro hitbox)
							CombatManager.AplicarDanioSegura(player, otherCharacter, areaDanio)
							print("ğŸ”¥ DaÃ±o en Ã¡rea a:", otherCharacter.Name, "(", areaDanio, ")")
						else
							print("â›” DaÃ±o en Ã¡rea evitado a aliado:", otherCharacter.Name)
						end
					end
				end
			end
		end
	else
		print("ğŸ§¯ Llamas del Olimpo no activas, no se aplica daÃ±o en Ã¡rea.")
	end
end

-- ğŸ—¡ï¸ Nythera - ataque rÃ¡pido sin stun
BasicAttacks["Nythera"] = function(character, target)
	ejecutarAtaqueBasico(character, false, 1.0) -- Sin stun, multiplicador 1.0
end

-- ğŸƒ Sonic - ataque muy rÃ¡pido
BasicAttacks["Sonic"] = function(character, target)
	ejecutarAtaqueBasico(character, false, 1.0) -- Sin stun, multiplicador 1.0
end

-- ğŸ‰ DragonYinYan - ataque medio con chance de stun
BasicAttacks["DragonYinYan"] = function(character, target)
	-- Verificar cooldown antes de atacar
	if not BasicAttackCooldown.canAttack(character) then
		return
	end

	-- ğŸš« VERIFICAR SI EL PERSONAJE PUEDE ATACAR
	if not personajePuedeAtacar(character) then
		return
	end

	local player = Players:GetPlayerFromCharacter(character)
	if not player or not target then return end

	-- ğŸš« VERIFICACIÃ“N CON EQUIPOMANGER
	if not puedeAtacarObjetivo(character, target) then
		print("âŒ DragonYinYan no puede atacar a este objetivo (aliado o invÃ¡lido)")
		return
	end

	-- ğŸ” Resolver modelo del target
	local targetModel = target
	if target:IsA("BasePart") or target:IsA("MeshPart") then
		targetModel = target:FindFirstAncestorOfClass("Model") or target.Parent
	elseif target:IsA("Humanoid") then
		targetModel = target.Parent
	end

	if not targetModel then return end

	local fuerza = character:GetAttribute("Fuerza") or 0
	local nivelMultiplier = getLevelMultiplier(character)
	local danioBase = math.floor(fuerza * 1.0 * nivelMultiplier)

	-- 50% de probabilidad de stun
	local aplicarStun = math.random() > 0.5

	-- ğŸ”¥ NUEVO: Aplicar marca Yin-Yang si la habilidad 3 estÃ¡ activa
	local marcaAplicada = false
	local DragonYinYanModule = require(game.ReplicatedStorage.Habilidades.DragonYinYanModule)
	if DragonYinYanModule.AplicarMarcaDesdeAtaqueBasico then
		marcaAplicada = DragonYinYanModule.AplicarMarcaDesdeAtaqueBasico(character, targetModel, character:GetAttribute("Habilidad3Nivel") or 1)
	end

	-- Solo aplicar hitbox si no se aplicÃ³ marca (la marca ya incluye daÃ±o)
	if not marcaAplicada then
		CombatManager.HitboxRapido(player, danioBase, aplicarStun)
	end

	print("ğŸ—¡ï¸ DragonYinYan basic attack:" .. (marcaAplicada and " (con marca)" : (aplicarStun and " (con stun)" : "")), danioBase)
end

-- ğŸ•¶ï¸ Blacktor - ataque sigiloso con bonus
BasicAttacks["Blacktor"] = function(character, target)
	-- Verificar cooldown antes de atacar
	if not BasicAttackCooldown.canAttack(character) then
		return
	end

	-- ğŸš« VERIFICAR SI EL PERSONAJE PUEDE ATACAR
	if not personajePuedeAtacar(character) then
		return
	end

	print("âš”ï¸ Blacktor ATTACK DEBUG")
	local player = Players:GetPlayerFromCharacter(character)
	if not player or not target then return end

	-- ğŸš« VERIFICACIÃ“N CON EQUIPOMANGER
	if not puedeAtacarObjetivo(character, target) then
		print("âŒ Blacktor no puede atacar a este objetivo (aliado o invÃ¡lido)")
		return
	end

	-- ğŸ” Resolver modelo del target
	local targetModel = target
	if target:IsA("BasePart") or target:IsA("MeshPart") then
		targetModel = target:FindFirstAncestorOfClass("Model") or target.Parent
	elseif target:IsA("Humanoid") then
		targetModel = target.Parent
	end

	if not targetModel then return end

	-- ğŸ§  Calcular daÃ±o segÃºn Fuerza y Nivel
	local fuerza = character:GetAttribute("Fuerza") or 0
	local nivelMultiplier = getLevelMultiplier(character)
	local danioBase = math.floor(fuerza * 1.0 * nivelMultiplier)

	-- ğŸ”¥ BONUS DE DAÃ‘O POR SIGILO
	if character:GetAttribute("SigiloActivo") then
		danioBase = math.floor(danioBase * 1.75) -- +75% de daÃ±o
		print("ğŸ—¡ï¸ Ataque sigiloso de Blacktor! DaÃ±o:", danioBase)
		character:SetAttribute("SigiloActivo", false)
	end

	CombatManager.HitboxRapido(player, danioBase, false) -- Sin stun
	print("ğŸ—¡ï¸ Blacktor basic attack:", danioBase)
end

-- ğŸ§Ÿ Zombie - ataque lento pero con stun
BasicAttacks["Zombie"] = function(character, target)
	ejecutarAtaqueBasico(character, true, 1.1) -- Con stun, multiplicador 1.1
end

-- âœ¨ Mireya - ataque mÃ¡gico dÃ©bil
BasicAttacks["Mireya"] = function(character, target)
	ejecutarAtaqueBasico(character, false, 0.7) -- Sin stun, multiplicador 0.7
end

-- ğŸ” DEBUG: Verificar que el mÃ³dulo se carga
print("ğŸ”„ BasicAttacks module cargado - Sistema de hitboxes rÃ¡pidos integrado con daÃ±o por Fuerza")

return BasicAttacks
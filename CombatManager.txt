--ReplicatedStorage/CombatManager
local CombatManager = {}

local Players = game:GetService("Players")
local EquipoManager = require(game.ReplicatedStorage:WaitForChild("EquipoManager"))
local Debris = game:GetService("Debris")
local VidaManager = require(game.ServerScriptService:WaitForChild("VidaManager"))
local EstadoManager = require(game.ServerScriptService:WaitForChild("EstadoManager"))
local HighlightModule = require(game.ServerScriptService:WaitForChild("HighlightModule"))

-- ðŸ” Identificar enemigo desde parte
function CombatManager.IdentificarEnemigoDesdeParte(parte)
	print("[CombatManager] IdentificarEnemigoDesdeParte called with parte:", parte and parte.Name or "nil")
	if not parte then return nil end
	local candidato = parte
	while candidato and not candidato:IsA("Model") do
		candidato = candidato.Parent
	end
	if candidato and candidato:IsA("Model") then
		local humanoide = candidato:FindFirstChildOfClass("Humanoid")
		if humanoide and humanoide.Health > 0 then
			print("[CombatManager] Enemigo identificado:", candidato.Name)
			return candidato
		end
	end
	print("[CombatManager] No enemigo identificado.")
	return nil
end

-- ðŸ’¥ Aplicar daÃ±o segura (validaciones de vida y equipo) CON EFECTO VISUAL
function CombatManager.AplicarDanioSegura(atacante, objetivo, cantidad)
	print("[CombatManager] AplicarDanioSegura called. Atacante:", atacante and atacante.Name or "nil", "Objetivo:", objetivo and objetivo.Name or "nil", "Cantidad:", cantidad)

	-- ðŸ›‘ VERIFICACIONES DETALLADAS
	if not atacante then 
		print("âŒ [CombatManager] Atacante es nulo")
		return 
	end
	if not objetivo then 
		print("âŒ [CombatManager] Objetivo es nulo")
		return 
	end

	-- Verificar estado del objetivo
	if EstadoManager.TieneEstado and EstadoManager.TieneEstado(objetivo, "Invulnerable") then 
		print("ðŸ›¡ï¸ [CombatManager] Objetivo es invulnerable: " .. objetivo.Name)
		return 
	end

	-- Verificar equipos con mÃ¡s detalle
	if not EquipoManager.PuedeAtacar then
		print("âŒ [CombatManager] EquipoManager.PuedeAtacar no existe")
		return
	end

	local puedeAtacar = EquipoManager.PuedeAtacar(atacante, objetivo)
	print("ðŸŽ¯ [CombatManager] EquipoManager.PuedeAtacar result:", puedeAtacar)

	if not puedeAtacar then 
		print("ðŸš« [CombatManager] No puede atacar por equipo. Atacante:", atacante.Name, "Objetivo:", objetivo.Name)
		return 
	end

	print("âœ… [CombatManager] PasÃ³ todas las validaciones, aplicando daÃ±o")
	VidaManager:AplicarDanio(atacante, objetivo, cantidad)

	-- âœ¨ NUEVO: APLICAR EFECTO VISUAL DE GOLPE
	CombatManager.AplicarEfectoGolpe(objetivo)
end

-- âœ¨ NUEVA FUNCIÃ“N: Aplicar efecto visual de golpe
function CombatManager.AplicarEfectoGolpe(objetivo)
	if not objetivo or not objetivo:IsA("Model") then
		print("âŒ [CombatManager] No se puede aplicar efecto: objetivo invÃ¡lido")
		return
	end

	-- Aplicar efecto de highlight
	local success, err = pcall(function()
		HighlightModule.New(objetivo)
	end)

	if success then
		print("âœ¨ [CombatManager] Efecto de golpe aplicado a:", objetivo.Name)
	else
		warn("âŒ [CombatManager] Error al aplicar efecto visual:", err)
	end
end

-- ðŸ§› Aplicar daÃ±o con robo de vida CON EFECTO VISUAL
function CombatManager.AplicarDanioConRoboVida(atacante, objetivo, cantidad)
	print("[CombatManager] AplicarDanioConRoboVida called. Atacante:", atacante and atacante.Name or "nil", "Objetivo:", objetivo and objetivo.Name or "nil", "Cantidad:", cantidad)
	if not atacante or not objetivo then 
		print("[CombatManager] Atacante u objetivo nulo. Cancelando daÃ±o.")
		return 
	end
	if EstadoManager.TieneEstado and EstadoManager.TieneEstado(objetivo, "Invulnerable") then 
		print("[CombatManager] Objetivo es invulnerable. Cancelando daÃ±o.")
		return 
	end
	if not EquipoManager.PuedeAtacar(atacante, objetivo) then 
		print("[CombatManager] No puede atacar por equipo. Cancelando daÃ±o.")
		return 
	end

	print("[CombatManager] Aplicando daÃ±o con robo de vida:", cantidad, "de", atacante.Name, "a", objetivo.Name)
	VidaManager:AplicarDanio(atacante, objetivo, cantidad)

	-- âœ¨ NUEVO: APLICAR EFECTO VISUAL
	CombatManager.AplicarEfectoGolpe(objetivo)

	-- â¤ï¸ Robar vida al atacante
	local character = atacante.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.Health > 0 then
			local vidaAntes = humanoid.Health
			humanoid.Health = math.min(humanoid.MaxHealth, humanoid.Health + cantidad)
			print("ðŸ’‰ Vida robada: " .. cantidad .. " (Antes: " .. vidaAntes .. ", DespuÃ©s: " .. humanoid.Health .. ")")
		else
			print("[CombatManager] No se pudo robar vida: Humanoid no vÃ¡lido o muerto.")
		end
	else
		print("[CombatManager] No se pudo robar vida: atacante sin Character.")
	end
end

-- ðŸ“¡ Buscar enemigos en radio
function CombatManager.BuscarEnemigosEnRadio(origen, radio, personajeOrigen)
	print("[CombatManager] BuscarEnemigosEnRadio called. Origen:", origen, "Radio:", radio, "PersonajeOrigen:", personajeOrigen and personajeOrigen.Name or "nil")
	local enemigos = {}
	for _, modelo in ipairs(workspace:GetDescendants()) do
		if modelo:IsA("Model") and modelo ~= personajeOrigen then
			local humanoide = modelo:FindFirstChildOfClass("Humanoid")
			local hrp = modelo:FindFirstChild("HumanoidRootPart")
			if humanoide and humanoide.Health > 0 and hrp then
				local distancia = (hrp.Position - origen).Magnitude
				if distancia <= radio then
					if EquipoManager.SonEnemigos(personajeOrigen, modelo) then
						table.insert(enemigos, modelo)
						print("[CombatManager] Enemigo encontrado en radio:", modelo.Name, "Distancia:", distancia)
					end
				end
			end
		end
	end
	print("[CombatManager] Total enemigos encontrados:", #enemigos)
	return enemigos
end

function CombatManager.BuscarObjetivo(posicion, radio, personajeOrigen)
	print("[CombatManager] BuscarObjetivo called. Posicion:", posicion, "Radio:", radio, "PersonajeOrigen:", personajeOrigen and personajeOrigen.Name or "nil")
	for _, modelo in ipairs(workspace:GetDescendants()) do
		if modelo:IsA("Model") and modelo ~= personajeOrigen then
			local humanoide = modelo:FindFirstChildOfClass("Humanoid")
			local hrp = modelo:FindFirstChild("HumanoidRootPart")
			if humanoide and humanoide.Health > 0 and hrp then
				local distancia = (hrp.Position - posicion).Magnitude
				if distancia <= radio then
					if EquipoManager.SonEnemigos(personajeOrigen, modelo) then
						print("[CombatManager] Objetivo encontrado:", modelo.Name, "Distancia:", distancia)
						return modelo
					end
				end
			end
		end
	end
	print("[CombatManager] No objetivo encontrado en radio.")
	return nil
end

-- ðŸ”¥ SISTEMA DE HITBOXES FÃSICOS (Integrado con tus validaciones)
function CombatManager.CrearHitboxFisico(atacante, config)
	local config = config or {}
	local danio = config.danio or 25
	local tamanio = config.tamanio or Vector3.new(5, 5, 5)
	local offset = config.offset or Vector3.new(0, 0, -3)
	local duracion = config.duracion or 0.4
	local efecto = config.efecto
	local duracionEfecto = config.duracionEfecto or 2
	local color = config.color or BrickColor.Red()
	local sonidoHit = config.sonidoHit

	local char = atacante.Character
	if not char then 
		print("âŒ [CombatManager] No se puede crear hitbox: atacante sin Character")
		return nil 
	end

	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then 
		print("âŒ [CombatManager] No se puede crear hitbox: sin HumanoidRootPart")
		return nil 
	end

	print("ðŸŽ¯ [CombatManager] Creando hitbox fÃ­sico para:", char.Name)

	-- Crear hitbox
	local hitbox = Instance.new("Part")
	hitbox.Name = "HitboxFisico_" .. char.Name
	hitbox.CanCollide = false
	hitbox.Size = tamanio
	hitbox.Transparency = 0.9
	hitbox.BrickColor = color
	hitbox.Material = Enum.Material.Glass
	hitbox.Anchored = true
	hitbox.CFrame = hrp.CFrame * CFrame.new(offset)
	hitbox.Parent = workspace

	-- ðŸ”¥ DETECCIÃ“N CON TUS VALIDACIONES EXISTENTES
	local conexion = hitbox.Touched:Connect(function(hit)
		-- âœ… USAR TU SISTEMA EXISTENTE para identificar enemigos
		local enemigo = CombatManager.IdentificarEnemigoDesdeParte(hit)

		if enemigo then
			-- âœ… VERIFICAR SI PUEDE ATACAR (usando tu sistema de equipos)
			if EquipoManager.PuedeAtacar(atacante, enemigo) then
				-- âœ… VERIFICAR SI EL OBJETIVO ES VULNERABLE
				if not EstadoManager.TieneEstado(enemigo, "Invulnerable") then
					-- âœ… USAR TU SISTEMA DE DAÃ‘O con todas las validaciones
					CombatManager.AplicarDanioSegura(atacante, enemigo, danio)

					-- âœ… USAR TU ESTADOMANAGER para efectos
					if efecto then
						EstadoManager.AplicarEstado(enemigo, efecto, duracionEfecto)
						print("ðŸŒ€ [CombatManager] Efecto aplicado:", efecto, "a", enemigo.Name)
					end

					-- âœ… SONIDO (opcional)
					if sonidoHit then
						-- Tu lÃ³gica de sonidos aquÃ­
					end
				else
					print("ðŸ›¡ï¸ [CombatManager] Objetivo invulnerable, daÃ±o cancelado")
				end
			else
				print("ðŸš« [CombatManager] No puede atacar (aliado o equipo)")
			end
		end
	end)

	-- DestrucciÃ³n automÃ¡tica
	delay(duracion, function()
		if conexion then
			conexion:Disconnect()
		end
		if hitbox and hitbox.Parent then
			hitbox:Destroy()
			print("ðŸ—‘ï¸ [CombatManager] Hitbox destruido despuÃ©s de", duracion, "segundos")
		end
	end)

	return hitbox
end

-- ðŸŽ¯ FUNCIONES DE CONVENIENCIA PARA DIFERENTES TIPOS DE ATAQUES
function CombatManager.AtaqueConHitboxBasico(atacante, danio)
	return CombatManager.CrearHitboxFisico(atacante, {
		danio = danio,
		tamanio = Vector3.new(5, 5, 5),
		offset = Vector3.new(0, 0, -3),
		color = BrickColor.Red()
	})
end

function CombatManager.AtaqueConHitboxYStun(atacante, danio, duracionStun)
	return CombatManager.CrearHitboxFisico(atacante, {
		danio = danio,
		efecto = "Aturdido",
		duracionEfecto = duracionStun or 2,
		tamanio = Vector3.new(5, 5, 5),
		offset = Vector3.new(0, 0, -3),
		color = BrickColor.Blue()
	})
end

function CombatManager.AtaqueConHitboxYRalentizar(atacante, danio, factorRalentizar, duracion)
	return CombatManager.CrearHitboxFisico(atacante, {
		danio = danio,
		efecto = "Ralentizado",
		duracionEfecto = duracion or 3,
		parametros = {factor = factorRalentizar or 0.5},
		tamanio = Vector3.new(5, 5, 5),
		offset = Vector3.new(0, 0, -3),
		color = BrickColor.Yellow()
	})
end

function CombatManager.AtaqueAreaConHitbox(atacante, danio, radio)
	return CombatManager.CrearHitboxFisico(atacante, {
		danio = danio,
		tamanio = Vector3.new(radio * 2, 5, radio * 2),
		offset = Vector3.new(0, 0, 0),
		color = BrickColor.Green()
	})
end

function CombatManager.AtaqueConoConHitbox(atacante, danio, distancia, angulo)
	return CombatManager.CrearHitboxFisico(atacante, {
		danio = danio,
		tamanio = Vector3.new(5, 5, distancia),
		offset = Vector3.new(0, 0, -distancia/2),
		color = BrickColor.Orange()
	})
end

-- ðŸš€ SISTEMA DE HITBOX RÃPIDO (Integrado con tu sistema de daÃ±o por Fuerza)
function CombatManager.HitboxRapido(plr, dmg, aplicarStun)
	print("âš¡ [CombatManager] HitboxRÃ¡pido activado para:", plr.Name, "DaÃ±o:", dmg)

	local Char = plr.Character
	if not Char then 
		print("âŒ [CombatManager] No hay character para HitboxRÃ¡pido")
		return 
	end

	local hrp = Char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Crear hitbox
	local hitbox = Instance.new("Part")
	hitbox.Name = "HitboxRapido"
	hitbox.CanCollide = false
	hitbox.Size = Vector3.new(5,5,5)
	hitbox.Transparency = 0.9
	hitbox.BrickColor = BrickColor.Red()
	hitbox.Material = Enum.Material.Glass
	hitbox.Anchored = true

	-- Parent y posiciÃ³n (con el delay mÃ­nimo)
	hitbox.Parent = Char
	wait(0.0001)
	hitbox.CFrame = hrp.CFrame * CFrame.new(0,0,-7.5) -- MÃ¡s lejos que el hitbox bÃ¡sico

	-- ðŸ”¥ DETECCIÃ“N MEJORADA CON TUS VALIDACIONES
	local yaGolpeo = false
	local conexion = hitbox.Touched:Connect(function(hit)
		if yaGolpeo then return end

		-- âœ… USAR TU SISTEMA DE IDENTIFICACIÃ“N
		local enemigo = CombatManager.IdentificarEnemigoDesdeParte(hit)

		if enemigo then
			-- âœ… VERIFICAR SI PUEDE ATACAR
			if EquipoManager.PuedeAtacar(plr, enemigo) then
				-- âœ… VERIFICAR SI EL OBJETIVO ES VULNERABLE
				if not EstadoManager.TieneEstado(enemigo, "Invulnerable") then
					yaGolpeo = true

					-- âœ… USAR TU SISTEMA DE DAÃ‘O (que usa Fuerza automÃ¡ticamente)
					CombatManager.AplicarDanioSegura(plr, enemigo, dmg)

					-- âœ… APLICAR STUN CON TU ESTADOMANAGER
					if aplicarStun then
						EstadoManager.AplicarEstado(enemigo, "Aturdido", 1)
						print("ðŸŒ€ [CombatManager] Stun aplicado con HitboxRÃ¡pido")
					end

					-- âœ… SONIDO (si existe en tu sistema)
					if game.ReplicatedStorage:FindFirstChild("Sounds") then
						local hitSound = game.ReplicatedStorage.Sounds:FindFirstChild("Hit")
						if hitSound then
							hitSound:Play()
						end
					end

					print("ðŸ’¥ [CombatManager] HitboxRÃ¡pido golpeÃ³ a:", enemigo.Name, "con", dmg, "de daÃ±o")
				else
					print("ðŸ›¡ï¸ [CombatManager] Objetivo invulnerable - HitboxRÃ¡pido")
				end
			else
				print("ðŸš« [CombatManager] No puede atacar (aliado) - HitboxRÃ¡pido")
			end
		end
	end)

	-- âœ… USAR DEBRIS PARA DESTRUCCIÃ“N AUTOMÃTICA
	Debris:AddItem(hitbox, 0.1)

	-- Limpiar conexiÃ³n cuando se destruya el hitbox
	delay(0.15, function()
		if conexion then
			conexion:Disconnect()
		end
	end)

	return hitbox
end

-- ðŸŽ¯ FUNCIONES ESPECIALIZADAS BASADAS EN HITBOX RÃPIDO
function CombatManager.AtaqueRapidoConStun(plr, dmg)
	return CombatManager.HitboxRapido(plr, dmg, true)
end

function CombatManager.AtaqueRapidoSinStun(plr, dmg)
	return CombatManager.HitboxRapido(plr, dmg, false)
end

-- ðŸ”„ COMPATIBILIDAD DIRECTA CON TU MÃ“DULO ORIGINAL
function CombatManager.Hit(dmg, plr, valor)
	-- Esta funciÃ³n mantiene compatibilidad con el cÃ³digo legacy
	print("ðŸ” [CombatManager] Usando funciÃ³n Hit legacy")
	CombatManager.HitboxRapido(plr, dmg, true)
end

-- ðŸ†• FUNCIONES ADICIONALES PARA MEJOR INTEGRACIÃ“N

-- ðŸ”„ Verificar si un personaje puede ser atacado (wrapper para EstadoManager)
function CombatManager.PuedeSerAtacado(character)
	if not character then return false end

	-- Verificar si estÃ¡ invulnerable
	if EstadoManager.TieneEstado(character, "Invulnerable") then
		return false
	end

	-- Verificar si estÃ¡ muerto
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then
		return false
	end

	return true
end

-- ðŸŽ¯ Ataque en Ã¡rea con hitbox rÃ¡pido
function CombatManager.AtaqueAreaRapido(plr, dmg, radio, aplicarStun)
	print("ðŸŒ€ [CombatManager] AtaqueAreaRapido activado para:", plr.Name)

	local Char = plr.Character
	if not Char then return end

	local hrp = Char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Buscar todos los enemigos en el radio
	local enemigos = CombatManager.BuscarEnemigosEnRadio(hrp.Position, radio, Char)

	-- Aplicar daÃ±o a cada enemigo
	for _, enemigo in ipairs(enemigos) do
		if CombatManager.PuedeSerAtacado(enemigo) then
			CombatManager.AplicarDanioSegura(plr, enemigo, dmg)

			if aplicarStun then
				EstadoManager.AplicarEstado(enemigo, "Aturdido", 1)
			end

			print("ðŸ’¥ Ataque Ã¡rea golpeÃ³ a:", enemigo.Name)
		end
	end

	return #enemigos
end

-- ðŸ†• NUEVAS FUNCIONES PARA EL SISTEMA DE IMPACTO (INTEGRACIÃ“N SIN ELIMINAR NADA)

-- ðŸŽ¯ NUEVA FUNCIÃ“N: HitboxRapido con configuraciÃ³n de impacto
function CombatManager.HitboxRapidoConImpacto(plr, dmg, configImpacto)
	print("âš¡ [CombatManager] HitboxRÃ¡pidoConImpacto activado para:", plr.Name, "DaÃ±o:", dmg)

	local Char = plr.Character
	if not Char then return end

	local hrp = Char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Crear hitbox
	local hitbox = Instance.new("Part")
	hitbox.Name = "HitboxRapidoImpacto"
	hitbox.CanCollide = false
	hitbox.Size = Vector3.new(5,5,5)
	hitbox.Transparency = 0.9
	hitbox.BrickColor = BrickColor.Red()
	hitbox.Material = Enum.Material.Glass
	hitbox.Anchored = true

	hitbox.Parent = Char
	wait(0.0001)
	hitbox.CFrame = hrp.CFrame * CFrame.new(0,0,-7.5)

	local yaGolpeo = false
	local conexion = hitbox.Touched:Connect(function(hit)
		if yaGolpeo then return end

		local enemigo = CombatManager.IdentificarEnemigoDesdeParte(hit)

		if enemigo then
			if EquipoManager.PuedeAtacar(plr, enemigo) then
				if not EstadoManager.TieneEstado(enemigo, "Invulnerable") then
					yaGolpeo = true

					CombatManager.AplicarDanioSegura(plr, enemigo, dmg)

					-- ðŸ†• APLICAR IMPACTO EN LUGAR DE ATURDIDO
					if configImpacto then
						local KnockbackManager = require(game.ServerScriptService:WaitForChild("KnockbackManager"))
						KnockbackManager.ProcesarImpacto(Char, enemigo, configImpacto)
					end

					print("ðŸ’¥ [CombatManager] HitboxRÃ¡pidoConImpacto golpeÃ³ a:", enemigo.Name, "con", dmg, "de daÃ±o")
				end
			end
		end
	end)

	Debris:AddItem(hitbox, 0.1)

	delay(0.15, function()
		if conexion then
			conexion:Disconnect()
		end
	end)

	return hitbox
end

-- ðŸ†• NUEVA FUNCIÃ“N: Ataque con impacto personalizado
function CombatManager.AtaqueConImpacto(plr, dmg, configImpacto)
	return CombatManager.HitboxRapidoConImpacto(plr, dmg, configImpacto)
end

-- ðŸ”¥ DEBUG: Mostrar informaciÃ³n del mÃ³dulo al cargar
print("âœ… [CombatManager] MÃ³dulo cargado completamente - Sistema listo")
print("   ðŸ”¥ Hitboxes fÃ­sicos: âœ…")
print("   ðŸš€ HitboxRapido: âœ…") 
print("   ðŸŽ¯ Ataques Ã¡rea: âœ…")
print("   ðŸ”„ Compatibilidad legacy: âœ…")
print("   âœ¨ Efectos visuales: âœ…")
print("   ðŸ’¥ Sistema de Impacto: âœ…")

return CombatManager